package frc.robot.commands.autos;

import choreo.auto.AutoFactory;
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;
import edu.wpi.first.wpilibj2.command.Commands;
import frc.robot.SSConstants;
import frc.robot.commands.SuperStructure;

/**
 * @deprecated not using PathPlannerLib anymore. Also moving forward we should define each auto in
 *     its own class for clarity
 */
@Deprecated(since = "PineTree")
public class AutoRoutinesWithPathFinding {
  private final AutoFactory m_factory;

  public AutoRoutinesWithPathFinding(AutoFactory factory) {
    m_factory = factory;
  }

  public AutoRoutine coralAndAlgaeAutoGeneratedLeg1() {
    String name = "OTF Coral and Algae Auto";
    AutoRoutine routine = m_factory.newRoutine(name);

    // Load the routine's trajectories
    // AutoTrajectory startToReefDTraj = routine.trajectory("StartToReefD");
    AutoTrajectory reefDToProcTraj = routine.trajectory("ReefDToProcessor");
    AutoTrajectory procToSourceTraj = routine.trajectory("ProcessorToSource");
    AutoTrajectory sourceToReefB = routine.trajectory("SourceToReefB");
    AutoTrajectory reefBToProcessor = routine.trajectory("ReefBToProcessor");

    // 1) Generate the a PathPlannerLib trajectory for the first leg. Go to reefD, then score on L4

    // when generating leg1, you don't need to reset odemetry at the start
    // Command leg1 =
    //     Commands.sequence(
    //         ScoreAssist.buildOTFPath(
    //             reefDToProcTraj.getInitialPose().get(), Constants.scoreAssistConstraints, 0,
    // false),
    //         SuperStructure.L4_PREP.getCommand(),
    //         SuperStructure.CORAL_SCORE.getCommand(),
    //         Commands.waitSeconds(0.2));

    // // When the routine begins, reset odometry and start the first trajectory

    // // when the routine starts, first run the path-finding command
    // routine
    //     .active()
    //     .onTrue(
    //         Commands.sequence(
    //             Commands.print(name + " started generated leg!"),
    //             leg1,
    //             Commands.waitSeconds(0.2),
    //             Commands.print(name + " started routine!"),
    //             // startToReefDTraj.resetOdometry(),
    //             SuperStructure.L3_PREP.getCommand(),
    //             SuperStructure.ALGAE_GRAB_AND_CORAL_SCORE.getCommand(),
    //             Commands.parallel(
    //                 SuperStructure.PROCESSOR_PREP.delayCommand(0.5), reefDToProcTraj.cmd())));

    // When the trajectory is done, score in processor. Then go to source
    reefDToProcTraj
        .done()
        .onTrue(
            Commands.sequence(
                SuperStructure.PROCESSOR_SCORE.getCommand(),
                Commands.parallel(
                    procToSourceTraj.cmd(), SuperStructure.STARTING_CONF.getCommand())));

    // When at the source, pick up coral and go to reef B
    procToSourceTraj
        .done()
        .onTrue(
            Commands.sequence(
                SuperStructure.SOURCE_CORAL_INTAKE.getCommand(), sourceToReefB.cmd()));

    // Prep elevator along the way
    sourceToReefB.atTime("PrepElevator").onTrue(SuperStructure.L3.getCommand());

    // Once at reef B, score and pick up algae; then go to processor
    sourceToReefB
        .done()
        .onTrue(
            Commands.sequence(
                SuperStructure.L3.getCommand(),
                SuperStructure.ALGAE_GRAB_AND_CORAL_SCORE.getCommand(),
                Commands.parallel(
                    SuperStructure.PROCESSOR_PREP.delayCommand(0.5), reefBToProcessor.cmd())));

    // When at the processor, score!
    reefBToProcessor.done().onTrue(SuperStructure.PROCESSOR_SCORE.getCommand());

    return routine;
  }

  public AutoRoutine scoreLotsOfCoralGeneratedLeg1() {
    String name = "OTF Score Lots of Coral";
    AutoRoutine routine = m_factory.newRoutine(name);

    // 1) Load the routine's trajectories

    // AutoTrajectory startToReefDTraj = routine.trajectory("Start2ToReefD");
    AutoTrajectory reefDToSource = routine.trajectory("ReefDToSource");
    AutoTrajectory sourceToReefB = routine.trajectory("SourceToReefB");
    AutoTrajectory reefBToSource = routine.trajectory("ReefBToSource");
    AutoTrajectory sourceToReefA = routine.trajectory("SourceToReefA");
    AutoTrajectory reefAToSource = routine.trajectory("ReefAToSource");

    // 1) Generate the a PathPlannerLib trajectory for the first leg. Go to reefD, then score on L4

    // when generating leg1, you don't need to reset odemetry at the start
    // Command leg1 =
    //     Commands.sequence(
    //         ScoreAssist.buildOTFPath(
    //             reefDToSource.getInitialPose().get(), Constants.scoreAssistConstraints, 0,
    // false),
    //         SuperStructure.L4_PREP.getCommand(),
    //         SuperStructure.CORAL_SCORE.getCommand(),
    //         Commands.waitSeconds(0.2));

    // // when the routine starts, first run the path-finding command
    // routine
    //     .active()
    //     .onTrue(
    //         Commands.sequence(
    //             Commands.print(name + " started generated leg!"),
    //             leg1,
    //             Commands.waitSeconds(0.1),
    //             Commands.print(name + " started routine!"),
    //             // reefDToSource.resetOdometry(),
    //             SuperStructure.L4_PREP.getCommand(),
    //             SuperStructure.CORAL_SCORE.getCommand(),
    //             Commands.waitSeconds(SSConstants.Auto.L4_SCORE_DELAY.getAsDouble()),
    //             Commands.parallel(
    //                 SuperStructure.SOURCE_CORAL_INTAKE.getCommand(), reefDToSource.cmd())));

    // 2) Run the rest of the routine

    // When the trajectory is done, intake; then go to reef B
    reefDToSource
        .done()
        .onTrue(
            Commands.parallel(
                SuperStructure.SOURCE_CORAL_INTAKE.getCommand(),
                Commands.sequence(
                    Commands.waitSeconds(SSConstants.Auto.INTAKE_DELAY.getAsDouble()),
                    sourceToReefB.cmd())));

    // Once at reef B, score and go to source
    sourceToReefB
        .done()
        .onTrue(
            Commands.sequence(
                SuperStructure.L4.getCommand(),
                SuperStructure.CORAL_SCORE.getCommand(),
                Commands.waitSeconds(SSConstants.Auto.L4_SCORE_DELAY.getAsDouble()),
                Commands.parallel(
                    SuperStructure.SOURCE_CORAL_INTAKE.getCommand(), reefBToSource.cmd())));

    // When the trajectory is done, intake; then go to reef A
    reefBToSource
        .done()
        .onTrue(
            Commands.parallel(
                SuperStructure.SOURCE_CORAL_INTAKE.getCommand(),
                Commands.sequence(
                    Commands.waitSeconds(SSConstants.Auto.INTAKE_DELAY.getAsDouble()),
                    sourceToReefA.cmd())));

    // Once at reef A, score and go to source
    sourceToReefA
        .done()
        .onTrue(
            Commands.sequence(
                SuperStructure.L4.getCommand(),
                SuperStructure.CORAL_SCORE.getCommand(),
                Commands.waitSeconds(0.2),
                Commands.parallel(
                    SuperStructure.SOURCE_CORAL_INTAKE.getCommand(), reefAToSource.cmd())));

    reefAToSource.done().onTrue(SuperStructure.SOURCE_CORAL_INTAKE.getCommand());

    return routine;
  }

  public AutoRoutine scoreOnceGeneratedLeg1() {
    String name = "OTF ScoreOnce";
    AutoRoutine routine = m_factory.newRoutine(name);

    var startToReefTraj = routine.trajectory("StartToReefE");
    // Command leg1 =
    //     Commands.sequence(
    //         ScoreAssist.buildOTFPath(
    //             AllianceFlipUtil.apply(startToReefTraj.getFinalPose().get()),
    //             Constants.scoreAssistConstraints,
    //             0,
    //             false),
    //         SuperStructure.L4_PREP.getCommand(),
    //         SuperStructure.CORAL_SCORE.getCommand(),
    //         Commands.waitSeconds(0.2));

    // // When the routine begins, reset odometry and start the first trajectory
    // routine
    //     .active()
    //     .onTrue(
    //         Commands.sequence(
    //             new InstantCommand(() -> System.out.println(name + " started")), leg1));

    return routine;
  }
}
